<!DOCTYPE html>
<html>
<head>
  <title></title>

  <script type="text/html" id="template-form">
    <form>
      <%= Html.editorForModel(model) %>
      <input type="submit" value="save"/>
    </form>
  </script>

  <link rel="stylesheet" type="text/css" href="css/bootstrap.css"></link>

  <script type="text/javascript" src="js/jquery-underscore-backbone.min.js"></script>
  <script type="text/javascript" src="js/piewpiew.backbone-0.0.1.min.js"></script>
  <script type="text/javascript">
    

    Person = piewpiew.models.Model.extend({
      fields: {
        
        firstName : new piewpiew.models.fields.StringField({
          label: "First name",
          minLength: 4,
          maxLength: 6
        }),

        lastName : new piewpiew.models.fields.StringField({
          label: "Last name",
          minLength: 4,
          maxLength: 6         
        }),

        emailAddress: new piewpiew.models.fields.EmailField({
          label: "Email address"
        })
      }
    });

    ListView = piewpiew.views.View.extend({
      tagName: "ul",

      itemTemplate: function(item) {
        return "";
      },

      itemTemplateContext: function(item) {
        return piewpiew.view.TemplateContext(item.toJSON());
      },

      initialize: function() {
        this.collection.bind("reset", this.render, this);
        this.collection.bind("add", this.handleAdd, this);
        this.collection.bind("remove", this.handleRemove, this);
      },

      handleAdd: function(model, collection, options) {
        this.appendItem(model.toJSON());
      },

      handleRemove: function() {
        console.log("remove", arguments);
      },

      render: function() {
        var self = this;

        $(this.el).empty();

        _(this.collection.models).each(function(model) {
          self.appendItem(model);
        });

        return this;
      },

      appendItem: function(item) {
        console.log(item);
        if (this.$el) {
          this.$el.append("<li>" + item.name + "</li>");
        } else {
          this.render();
        }
      }
    });

    FormView = piewpiew.views.View.extend({

      template: function() {
        var buf = [];

        buf.push('<form class="form-horizontal">');

        if (this.model.id) {
          buf.push('<%= Html.hidden("id", model.id) %>');
        }

        buf.push('<%= Html.hidden("cid", model.cid) %>');
        buf.push('<%= Html.editorForModel(model) %>');
        buf.push('<input type="submit" value="save"/>');
        buf.push('</form>');

        return buf.join("\n");
      },

      initialize: function(options) {
        if (this.model) {
          this.model.bind("error", this.handleError, this);
        } 
      },

      templateContext: function() {
        return {
          model:this.model
        };
      },

      events: {
        'submit form': 'handleSubmit',
        'blur input': 'handleBlur',
        'focus input': 'handleFocus' 
      },

      handleSubmit: function(e) {
        var formData = this.$('form').serializeObject();

        this.clearErrors();

        if (null != this.model) {
          if (this.model.set(formData)) this.trigger("submit", this);
        }     

        e.preventDefault();
      },

      handleFocus: function(e) {

      },

      handleBlur: function(e) {
        var $field = $(e.target);
        this.clearErrorFor($field.attr('name'));
        this.model.set($field.attr('name'), $field.val());
      },

      /**
       * Handlder for our model's validation error event. Displays error messages for
       * each of the fields that failed validation.
       */
      handleError: function(model, errors) {
        var view = this;

        _.each(errors, function(messages, name) {
          var msg = view.formatErrorMessagesFor(name,messages);
          var errorEl = view.formatErrorElementFor(name, msg);
          view.clearErrorFor(name);
          view.attachErrorElementFor(name, errorEl);          
        });
      },

      /** 
       * Clears all errors from the form view. If you implement your own validation
       * error message strategy you should override this.
       */
      clearErrors: function() {
        this.$(".control-group.error .help-inline").remove();
        this.$(".control-group.error").removeClass("error");
      },

      /**
       * Clears error message for a particular field
       *
       * @param {name}
       *  Name of the field
       */
      clearErrorFor: function(name) {
        this.$(".control-group-for-"+name+".error .help-inline").remove();
        this.$(".control-group-for-"+name+".error").removeClass("error");
      },

      /**
       * Formats validation error messages for a field. Overriding classes
       * can implement their own version to provide custom formatting for
       * certain fields.
       *
       * @param {string} name
       *  The name of the field
       * @param {array} messages
       *  An an array of validation messages for the field
       */
      formatErrorMessagesFor: function(name, messages) {
        return messages.join(" ");
      },

      /**
       * Formats a label for validation error message. Used to wrap the message
       * output generated by formatMessageFor().
       *
       * @param {string} name
       *  Name of the fied the message is for
       * @param {string} message
       *  The message string
       * @return {string}
       */
      formatErrorElementFor: function(name, message) {
        return '<span class="help-inline generated">' + message + '</span>';
      },

      /**
       * Attaches a validation error element to the dom. You can override this method
       * to customise where error elements are attached in the dom, relative to their
       * associated field
       *
       * @param {string} name
       *  Name of the field that the error element is associated with
       * @param {string} errorElement
       *  HTML string for the error element
       */
      attachErrorElementFor: function(name, errorElement) {
        // Attach the element and also append the 'error' class to the containing
        // 'control-group' element. This approach is closely coupled to how our other
        // error formatting functions work. The idea is if you want to implement a
        // different error messaging strategy, then you will probably want to overwrite
        // all these functions together.
        var $input = this.$("*[name=" + name + "]");
        $input.parent().append(errorElement);
        $input.closest('.control-group').addClass('error');
      }
    });

    Application = piewpiew.Application.extend({

      el: "#app",

      initializeModel: function() {
        this.registerModel('model', new Person({
          firstName: "Barry",
          lastName: "Smith"
        }));  
      },

      initializeView: function() {
        this.registerView('view', new FormView({
          model: this.getModel('model')
        }).bind("submit", function(formView) {
          console.log("You submitted ", formView.model.toJSON());
        }));
      },

      startup: function() {
        $(this.el).append(this.getView('view').render().$el);
      }
    });

  </script>

  
</head>
<body>
  <div class="container">
    <div id="app" class="span12"></div>
    <div class="span12">
      <form class="well">
        <input type="text"/>
      </form>

    </div>
  </div>
  


  <script type="text/javascript">
    var app = new Application();

    $(function() {
    //  app.startup();
    });

    var collection = new Backbone.Collection();
    var listView = new ListView({
      collection:collection
    });

    $("#app").append(listView.render().$el);

  </script>
</body>
</html>