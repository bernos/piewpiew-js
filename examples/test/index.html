<!DOCTYPE html>
<html>
<head>
  <title></title>

  <script type="text/html" id="template-form">
    <form>
      <%= Html.editorForModel(model) %>
      <input type="submit" value="save"/>
    </form>
  </script>

  <link rel="stylesheet" type="text/css" href="css/bootstrap.css"></link>


  <script type="text/javascript" src="js/jquery-underscore-backbone.min.js"></script>
  <script type="text/javascript" src="js/piewpiew.backbone-0.0.1.min.js"></script>
  <script type="text/javascript">


    Person = piewpiew.models.Model.extend({
      fields: {
        
        firstName : new piewpiew.models.fields.StringField({
          label: "First name",
          minLength: 4,
          maxLength: 6
        }),

        lastName : new piewpiew.models.fields.StringField({
          label: "Last name",
          minLength: 4,
          maxLength: 6         
        }),

        emailAddress: new piewpiew.models.fields.EmailField({
          label: "Email address"
        })
      }
    });

<<<<<<< HEAD
    ListView = piewpiew.views.View.extend({
      tagName: "ul",

      itemTemplate: function(item) {
        return "<li>"+item.toString()+"</li>";
      },

      itemTemplateContext: function(item) {
        if (typeof item.toJSON == 'function') {
          item = item.toJSON();
        }

        return piewpiew.views.TemplateContext(item);
      },

      itemView: null,

      initialize: function(options) {
        this.collection.bind("reset", this.render, this);
        this.collection.bind("add", this.handleAdd, this);
        this.collection.bind("remove", this.handleRemove, this);

        _.extend(this, options);
      },

      /**
       * Handler for our model "add" event
       */
      handleAdd: function(model, collection, options) {
        this.appendItem(model);
      },

      /**
       * Handler for our model "remove" event
       */
      handleRemove: function() {
        
      },

      render: function() {
        var self = this;

        $(this.el).empty();

        _(this.collection.models).each(function(model) {
          self.appendItem(model);
        });

        return this;
      },

      /**
       * Appends an item to the list view. If the ListView.itemView property
       * is set (usually to a class that extends Backbone.View) then an instance
       * of that view will be created, its model will be set to the item to be 
       * appended, and it will be rendered and appended.
       *
       * If no itemView property is set, then we will use ListView.itemTemplate
       * to render the item. Context for the itemTemplate is constructed by calling
       * listView.itemTemplateContext
       */
      appendItem: function(item) {        
        // TODO: do we really need to check $el?
        console.log("append", item);
        if (this.$el) {
          var content = "";

          if (this.itemView) {
            var view = new this.itemView({
              model: item
            });

            content = view.render().$el;
          } else {
            var tmpl;

            if (typeof this.itemTemplate == 'function') {
              tmpl = this.itemTemplate(item);
            } else {
              tmpl = this.itemTemplate;
            }

            content = piewpiew.views.template(tmpl, this.itemTemplateContext(item));
          }

          this.$el.append(content);
        } else {
          this.render();
        }
      }
    });

    FormView = piewpiew.views.View.extend({

      template: function() {
        var buf = [];

        buf.push('<form class="form-horizontal">');

        if (this.model.id) {
          buf.push('<%= Html.hidden("id", model.id) %>');
        }

        buf.push('<%= Html.hidden("cid", model.cid) %>');
        buf.push('<%= Html.editorForModel(model) %>');
        buf.push('<input type="submit" value="save"/>');
        buf.push('</form>');

        return buf.join("\n");
      },

      initialize: function(options) {
        if (this.model) {
          this.model.bind("error", this.handleError, this);
        } 
      },

      templateContext: function() {
        return {
          model:this.model
        };
      },

      events: {
        'submit form': 'handleSubmit',
        'blur input': 'handleBlur',
        'focus input': 'handleFocus' 
      },

      handleSubmit: function(e) {
        var formData = this.$('form').serializeObject();

        this.clearErrors();

        if (null != this.model) {
          if (this.model.set(formData)) this.trigger("submit", this);
        }     

        e.preventDefault();
      },

      handleFocus: function(e) {

      },

      handleBlur: function(e) {
        var $field = $(e.target);
        this.clearErrorFor($field.attr('name'));
        this.model.set($field.attr('name'), $field.val());
      },

      /**
       * Handlder for our model's validation error event. Displays error messages for
       * each of the fields that failed validation.
       */
      handleError: function(model, errors) {
        var view = this;

        _.each(errors, function(messages, name) {
          var msg = view.formatErrorMessagesFor(name,messages);
          var errorEl = view.formatErrorElementFor(name, msg);
          view.clearErrorFor(name);
          view.attachErrorElementFor(name, errorEl);          
        });
      },

      /** 
       * Clears all errors from the form view. If you implement your own validation
       * error message strategy you should override this.
       */
      clearErrors: function() {
        this.$(".control-group.error .help-inline").remove();
        this.$(".control-group.error").removeClass("error");
      },

      /**
       * Clears error message for a particular field
       *
       * @param {name}
       *  Name of the field
       */
      clearErrorFor: function(name) {
        this.$(".control-group-for-"+name+".error .help-inline").remove();
        this.$(".control-group-for-"+name+".error").removeClass("error");
      },

      /**
       * Formats validation error messages for a field. Overriding classes
       * can implement their own version to provide custom formatting for
       * certain fields.
       *
       * @param {string} name
       *  The name of the field
       * @param {array} messages
       *  An an array of validation messages for the field
       */
      formatErrorMessagesFor: function(name, messages) {
        return messages.join(" ");
      },

      /**
       * Formats a label for validation error message. Used to wrap the message
       * output generated by formatMessageFor().
       *
       * @param {string} name
       *  Name of the fied the message is for
       * @param {string} message
       *  The message string
       * @return {string}
       */
      formatErrorElementFor: function(name, message) {
        return '<span class="help-inline generated">' + message + '</span>';
      },

      /**
       * Attaches a validation error element to the dom. You can override this method
       * to customise where error elements are attached in the dom, relative to their
       * associated field
       *
       * @param {string} name
       *  Name of the field that the error element is associated with
       * @param {string} errorElement
       *  HTML string for the error element
       */
      attachErrorElementFor: function(name, errorElement) {
        // Attach the element and also append the 'error' class to the containing
        // 'control-group' element. This approach is closely coupled to how our other
        // error formatting functions work. The idea is if you want to implement a
        // different error messaging strategy, then you will probably want to overwrite
        // all these functions together.
        var $input = this.$("*[name=" + name + "]");
        $input.parent().append(errorElement);
        $input.closest('.control-group').addClass('error');
      }
    });
=======
>>>>>>> Moved FormView and ListView from example page to View module

    Application = piewpiew.Application.extend({

      el: "#app",

      initializeModel: function() {
        this.registerModel('model', new Person({
          firstName: "Barry",
          lastName: "Smith"
        }));  
      },

      initializeView: function() {
        this.registerView('view', new FormView({
          model: this.getModel('model')
        }).bind("submit", function(formView) {
          console.log("You submitted ", formView.model.toJSON());
        }));
      },

      startup: function() {
        $(this.el).append(this.getView('view').render().$el);
      }
    });

  </script>

  
</head>
<body>
  <div class="container">
    <div id="app" class="span12"></div>
  </div>
  


  <script type="text/javascript">
    var app = new Application();

    $(function() {
      app.startup();
    });

    ItemView = piewpiew.views.View.extend({
      template: '<li><a class="show-age" href="#"><%= firstName %></a></li>',

      events: {
        'click .show-age' : 'handleClick'
      },

      handleClick : function(e) {
        alert(this.model.get("lastName"));
        e.preventDefault();
      }
    });

    PersonCollection = Backbone.Collection.extend({
      model: Person
    });

    var collection = new PersonCollection();
    var listView = new ListView({
      collection:collection,
      itemView: ItemView
      //itemTemplate: '<li><%= Html.label("name", "Name") %>:<span><%= name %></span><%= Html.label("age", "Age") %>: <span><%= age %></span></li>'
    });

    //$("#app").append(listView.render().$el);

    collection.add({firstName:"brdan", lastName:"mchon"});

  </script>
</body>
</html>