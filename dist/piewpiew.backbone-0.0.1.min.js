/* piewpiew.backbone-0.0.1.min.js */
(function(root, factory) {
  // If AMD is available, use the define() method to load our dependencies 
  //and declare our module
  if (typeof define === 'function' && define.amd) {
    define(['underscore'], function(_) {
      return factory(root, _);
    });
  }
  // Otherwise we will attach our module to root, and pass references to our 
  // dependencies into the factory. We're assuming that our dependencies are 
  // also attached to root here, but they could come from anywhere 
  else 
  {
    root.piewpiew = factory(root, _);
  }
})(this, function(root, _) {
  var piewpiew = {};

  /**
   * Simple string formatting function. Replaces all occurances of ${token}
   * with values from a context object.
   *
   * @param {String} str
   *  The input string, containing tokens to be replace.
   * @param {Object} o
   *  Token values to be substituted into the input string.
   * @return {String}
   */
  piewpiew.printf = function(str, o) {
    for (var t in o) {
      var re = new RegExp("\\$\\{" + t + "\\}", "g");
       str = str.replace(re, o[t]);
    }
    return str;
  };

  /**
   * Helper function used by other piewpiew modules to resolve config values.
   * Modules will often have a config object, containing various configuration
   * options, like templates, message string and so on. Sometimes these values
   * are scalars, sometimes they are complex types, and sometimes they are
   * functions that need to be executed at call time in order to return the
   * actual config value. Modules can pass the config item to this function and
   * it will derive the value of the config item based on its type.
   */
  piewpiew.configValue = function(configItem) {
    // If the item is a function, call it and return the return value
    if (typeof configItem == 'function') {
      return configItem();
    }
    return configItem;
  };

  /**
   *  piewpiew.Class
   *  --------------------------------------------------------------------------
   *  Utility function for defining 'Classes'. 
   */
  var initializing = false;
    
  piewpiew.Class = function() {
    var methods = null;
    var parent  = null;
                
    /**
     * Default constructor for our new class. All classes created using the 
     * piewpiew.Class() method will share this constructor.
     */
    var klass = function() {
      if(!initializing) {
        this.initialize.apply(this, arguments);
      }
    };
      
    /**
     * If the first argument is a function, assume it is the "class" from which 
     * the new class will inherit. In this case the second argument is an object 
     * containing the methods and properties for the new class.
     *
     * If the first argument is not a function, then we interpret it as an 
     * object containing the methods and properties of the new class
     */
    if (typeof arguments[0] === 'function') {
      parent = arguments[0];
      methods = arguments[1];
    } else {
      methods = arguments[0];
    }

    if (parent) {
      // Set the initializing flag to prevent the normal initialization methods 
      // firing when creating the new prototype object
      initializing = true;
      klass.prototype = new parent();
      initializing = false;
    }

    _.extend(klass.prototype, methods);
    
    klass.prototype.constructor = klass;

    if (!klass.prototype.initialize) {
      klass.prototype.initialize = function(){};
    } 

    klass.extend = function(o) {
      return piewpiew.Class(this, o);
    }

    return klass;
  };

  return piewpiew;
});(function(root, factory) {
  // If AMD is available, use the define() method to load our dependencies 
  //and declare our module
  if (typeof define === 'function' && define.amd) {
    define(['underscore', 'backbone', 'piewpiew'], function(_, Backbone, piewpiew) {
      return factory(root, _, Backbone, piewpiew);
    });
  }
  // Otherwise we will attach our module to root, and pass references to our 
  // dependencies into the factory. We're assuming that our dependencies are 
  // also attached to root here, but they could come from anywhere 
  else 
  {    
    root.piewpiew = factory(root, _, Backbone, piewpiew);
  }
})(this, function(root, _, Backbone, piewpiew) {  

  /**
   *  piewpiew.Application
   *  -------------------------------------------------------------------------
   *  The Application class represents the 'core' of our app or app component. 
   *  It provides a consistent point of access to views and models in our app
   *  via the regsiterView, registerModel, getView, getModel methods.
   */    
  piewpiew.Application = piewpiew.Class({

    /**
     * Default element for the application is the body tag
     */
    el: 'body',

    /**
     * Initializes the Application instance.
     *
     * @param {Object} options
     *  Default options for the app
     */
    initialize: function(options) {

      options || (options = {});

      var defaults;

      if (defaults = this.defaults) {
        if (typeof defaults == 'function') {
          defaults = defaults.call(this);
        }
        options = _.extend({}, defaults, options);
      }

      this._routerMap   = {};
      this._modelMap    = {};
      this._viewMap     = {};

      this.initializeOptions(options);
      this.initializeRouter();
      this.initializeModel();
      this.initializeView();
      this.initializeController();

      return this;
    },

    /**
     * Initialize the app with options passed to the constructor
     */
    initializeOptions: function(options) {
      _.extend(this, options);
    },

    /**
     * Register your router(s) here.
     */
    initializeRouter: function() { 
      if (this.routes) {
        var routes = this.normalizeRoutes(this.routes);

        this.registerRouter('default', new Backbone.Router({
          routes: routes
        }));

      }

      return this; 
    },

    /**
     * Register your models with the app here.
     */
    initializeModel: function() { return this; },

    /**
     * Register your views with the app here.
     */
    initializeView: function() { return this; },

    /**
     * Initialize the controller here
     */
    initializeController: function() { return this; },

    /**
     * Registers a router with the app
     *
     * @param {String} name
     *  Name of the router
     * @param {Backbone.Router} router
     *  A router to register
     */
    registerRouter: function(name, router) {
      this._routerMap[name] = router;
    },

    normalizeRoutes: function(routes) {
      if (this.baseUrl) {
        normalizedRoutes = {};
        
        for (var pattern in routes) {
          var p = pattern.length ? this.baseUrl + '/' + pattern : this.baseUrl;

          normalizedRoutes[p] = routes[pattern];
        }  

        return normalizedRoutes;
      }

      return routes;
    },

    /**
     * Retrieve a router by name
     *
     * @param {String} name
     *  The name of the router to retrieve
     * @return {Backbone.Router} the requested router or null if no router has
     *  been registered with the provided name
     */
    getRouter: function(name) {
      return this._routerMap[name];
    },

    /**
     * Registers a model with the App. The model's app property will be set
     * to reference this app. If the model has an onRegister() method it will
     * be called
     *
     * @param {String} name
     *  A name to register the model under
     * @param {Backbone.Model} model
     * @return {App}
     */
    registerModel: function(name, model) {
      this._modelMap[name] = model;
      model.app = this;

      if (typeof model.onRegister == 'function') {
        model.onRegister(this);
      }

      return this;
    },

    /**
     * Retrieve a model from the app.
     *
     * @param {String} name
     *  The name of the model to retrieve
     * @return {Backbone.Model}
     */
    getModel: function(name) {
      return this._modelMap[name]
    },

    /**
     * Registers a view with the App. The view's app property will be set
     * to reference this app. If the view has an onRegister() method it will
     * be called
     *
     * @param {String} name
     *  A name to register the view under
     * @param {Backbone.View} view
     * @return {App}
     */
    registerView: function(name, view) {
      this._viewMap[name] = view;
      view.app = this;

      if (typeof view.onRegister == 'function') {
        view.onRegister(this);
      }

      return this;
    },

    /**
     * Retrieve a view from the app
     *
     * @param {String} name
     *  Name of the view to retrieve
     * @return {Backbone.View}
     */
    getView: function(name) {
      return this._viewMap[name];
    },

    /**
     * Binds a command class to an event source and event name. The App
     * will create an instance of the command class, and call it's execute()
     * method whenever the eventSource triggers the event. The command's
     * execute() method will receive the arguments provided by the event
     *
     * @param {Function} commandClass
     *  Constructor of a command class. Command classes must implement an
     *  execute() method
     * @param {Object} eventSource
     *  The event source that the command will be bound to
     * @param {String} eventName
     *  The name of the event the command will be bound to
     * @return {App}
     */
    registerCommand: function(commandClass, eventSource, eventName) {
      var app = this;

      eventSource.bind(eventName, function() {
        var command = new commandClass(app);
        command.execute.apply(command, arguments)  
      });

      return this;
    }
  });

  /**
   *  piewpiew.SimpleCommand base class
   *  --------------------------------------------------------------------------
   *  Basic command class implementation
   */

  piewpiew.SimpleCommand = piewpiew.Class({
    initialize: function(app) {
      this.app = app;
    },

    execute: function() { return this; }
  });

  /**
   *  piewpiew.MacroCommand base class
   *  --------------------------------------------------------------------------
   *  Basic macro commadn class implementation. Macro commands can contain 
   *  multiple subcommands which will be executed in series.
   */
  
  piewpiew.MacroCommand = piewpiew.Class({
    initialize: function(app) {
      this.app = app;
      this.subCommands = [];
      this.initializeMacroCommand();
    },

    /**
     * Initialize the MacroCommand instance. Normally you will override this
     * an call this.addSubCommand() to add sub commands to the MacroCommand.
     */
    initializeMacroCommand: function() { return this },

    /**
     * Adds a sub command to the MacroCommand
     *
     * @param {Function} commandClass
     *  Constructor function of the sub command to add
     */
    addSubCommand: function(commandClass) {
      this.subCommands.push(commandClass);
      return this;
    },

    /**
     * Executes the MacroCommand. Iterates over the collection of sub commands
     * and executes them one after the other
     */
    execute: function() {
      while(this.subCommands.length > 0) {
        var commandClass = this.subCommands.shift();
        var command      = new commandClass(this.app);

        command.execute.apply(command, arguments);
      }
      return this;
    }
  });

  return piewpiew;
});














































(function(root, factory) {
  // If AMD is available, use the define() method to load our dependencies 
  //and declare our module
  if (typeof define === 'function' && define.amd) {
    define(['underscore', 'backbone', 'piewpiew'], function(_, Backbone, piewpiew) {
      return factory(root, _, Backbone, piewpiew);
    });
  }
  // Otherwise we will attach our module to root, and pass references to our 
  // dependencies into the factory. We're assuming that our dependencies are 
  // also attached to root here, but they could come from anywhere 
  else 
  {    
    root.piewpiew = factory(root, _, Backbone, piewpiew);
  }
})(this, function(root, _, Backbone, piewpiew) {  
  
  piewpiew.models || (piewpiew.models = {});

  /**
   *  piewpiew.models.Config
   *  ==========================================================================
   *  
   *  Any and all strings for messages, templates and so forth should live here,
   *  and be retrieved by objects in the models module, rather than declared on
   *  objects themselves. Just makes it easier to change stuff as you don't need
   *  to go looking for strings hidden away in source.
   */
  piewpiew.models.Config = {

    messages: {
      
    },

    templates: {
       modelEditor: function() {
        var buf = [];

        buf.push("<% _.each(model.fields, function(field, name) { %>");
        buf.push("<div>");
        buf.push("<%= Html.editorForField(model, field) %>");
        buf.push("</div>");
        buf.push("<% }); %>");

        return buf.join("\n");
      }
    }    
  };

  // Shortcut access to config stuff  
  var c    = piewpiew.configValue;
  var conf = piewpiew.models.Config;
  var msg  = piewpiew.models.Config.messages;
  var tmpl = piewpiew.models.Config.templates;


  /**
   *  piewpiew.models.Model base class
   *  --------------------------------------------------------------------------
   *  Adds formal field definitions and a validation framework to the base 
   *  Backbone Model class.
   */
  piewpiew.models.Model = Backbone.Model.extend({

    /**
     * Custom implementation of toJSON that ensures the models cid and id (if 
     * set) are included in the json representation of the model
     */
    toJSON: function() {
      return _.extend(Backbone.Model.prototype.toJSON.apply(this), {
        id: this.id,
        cid: this.cid
      });
    },

    editorTemplate: function() {
      return c(tmpl.modelEditor);
    },

    editorTemplateContext: function() {
      return {
        model:this
      }
    },

    initialize: function(attributes, options) {

      // Initialize each of our field objects...
      _.each(this.fields, function(field, name) {
        
        attributes || (attributes = {});

        // Set a default label if none has been provided...
        if (!field.label) {
          field.label = name;
        }

        field.name  = name;
      });
    },
    
    /**
     * Iterate over each of the model's field definitions and validate the
     * corresponding value from the model instance. Returns either and object of
     * errors or false if no validation errors occured. The structure of the 
     * error object is:
     *
     *  {
     *    "field-one-name" : [
     *      "Error message one",
     *      "Error message two"
     *    ],
     *    "field-two-name" : [
     *      "Error message one",
     *      "Error message two"
     *    ]
     *  }
     */
    validate: function(attrs) {
      var errors = {};
      var isValid = true;
      var model = this;

      _.each(attrs, function(value, key) {
        if (model.fields[key]) {
          var e = model.fields[key].validate(value);
          if (e) {
            isValid = false;
            errors[key] = e;
          }
        }
      });

      if (!isValid) return errors;
    }
  });

  return piewpiew;
});














































(function(root, factory) {
  // If AMD is available, use the define() method to load our dependencies 
  //and declare our module
  if (typeof define === 'function' && define.amd) {
    define(['underscore', 'backbone', 'piewpiew'], function(_, Backbone, piewpiew) {
      return factory(root, _, Backbone, piewpiew);
    });
  }
  // Otherwise we will attach our module to root, and pass references to our 
  // dependencies into the factory. We're assuming that our dependencies are 
  // also attached to root here, but they could come from anywhere 
  else 
  {    
    root.piewpiew = factory(root, _, Backbone, piewpiew);
  }
})(this, function(root, _, Backbone, piewpiew) {  
  
  /**
   *  piewpiew.models.validators namespace
   *  ==========================================================================
   *  
   */
  piewpiew.models || (piewpiew.models = {});
  piewpiew.models.validators || (piewpiew.models.validators = {});

  /**
   *  piewpiew.models.validators.Config
   *  ==========================================================================
   *  
   *  Any and all strings for messages, templates and so forth should live here,
   *  and be retrieved by objects in the models module, rather than declared on
   *  objects themselves. Just makes it easier to change stuff as you don't need
   *  to go looking for strings hidden away in source.
   */
  piewpiew.models.validators.Config = {

    messages: {
      
      /* StringValidator */
      stringTooLongNoMinLength:  "String must have no more than ${maxLength} characters"
      ,stringTooShortNoMaxLength: "String must have at least ${minLength} characters"
      ,stringOutOfRange:          "String must have between ${minLength} and ${maxLength} characters"
      
      /* RangeValidator */
      ,rangeOutOfRange: "A value between ${min} and ${max} is required."
      
      /* RegexValidator */
      ,regexNoMatch: "The supplied string does not match the regular expression."
      
      /* EmailValidator */
      ,emailInvalid: "${value} is not a valid email address."
    }    
  };

  // Shortcut access to config stuff  
  var c    = piewpiew.configValue;
  var conf = piewpiew.models.validators.Config;
  var msg  = piewpiew.models.validators.Config.messages;

  /**
   * piewpiew.models.validators.Validator  base class
   * --------------------------------------------------------------------------
   *  
   */
  piewpiew.models.validators.Validator = piewpiew.Class({
    initialize: function(options) {
      options || (options = {});
      options.messages || (options.messages = {});

      _.extend(this, options);

      this.messages = this.defaultMessages();

      _.extend(this.messages, options.messages);
    },

    defaultMessages: function() {
      return {};
    },

    validate: function(value) {
      return [];
    }
  });

  /**
   * piewpiew.models.validators.StringValidator class. 
   * --------------------------------------------------------------------------
   * 
   * Ensures that a string is between a min and max length
   *
   * @property {Number} minLength
   *  Minimum length for the string. Use -1 for no minimum length
   * @property {Number} maxLength
   *  Maximum length for the string. Use -1 for no maximum length
   *
   * Validation messages
   *  outOfRange - String is not between minLength and maxLength
   *  tooLongNoMinLength - String is longer than max length with no minLength
   *    specified
   *  tooShortNoMaxLength - String is shorter than min length with no maxLength
   *    specified
   */
  piewpiew.models.validators.StringValidator = piewpiew.models.validators.Validator.extend({
    minLength: -1,
    maxLength: -1,

    defaultMessages: function() {
      return {
        tooLongNoMinLength : c(msg.stringTooLongNoMinLength),
        tooShortNoMaxLength : c(msg.stringTooShortNoMaxLength),
        outOfRange : c(msg.stringTooShortNoMaxLength)
      }
    },

    validate: function(value) {
      var errors = [];

      if (this.maxLength > -1) {
        if (value.length > this.maxLength) {
          errors.push((this.minLength > -1) ? piewpiew.printf(this.messages.outOfRange, this) : piewpiew.printf(this.messages.tooLongNoMinLength, this));
        }
      }

      if (this.minLength > -1) {
        if (value.length < this.minLength) {
          errors.push((this.maxLength > -1) ? piewpiew.printf(this.messages.outOfRange, this) : piewpiew.printf(this.messages.tooShortNoMaxLength, this));
        }
      }

      return errors;
    }
  });

  /**
   * piewpiew.models.validators.RangeValidator
   * --------------------------------------------------------------------------
   *
   * Range validator class. Determines whether a numeric value is between a
   * minimum and maximum boundary.
   *
   * @property {Number} min
   *  Minimum allowed value in range
   * @property {Number} max
   *  Maximum allowed valud in range. Set this lower than min to allow 
   *  unbounded values
   *
   * Validation messages:
   *  outOfRange - Displayed when the value being validated is out of range
   */
  piewpiew.models.validators.RangeValidator = piewpiew.models.validators.Validator.extend({
    min: 0,
    max: -1,

    defaultMessages: function() {
      return {
        outOfRange: c(msg.rangeOutOfRange)
      }
    },

    validate: function(value) {
      var errors = [];

      if (this.max < this.min) return errors;

      if (value < this.min || value > this.max) {
        errors.push(piewpiew.printf(this.messages.outOfRange, this));        
      }

      return errors;
    }
  });

  /**
   * piewpiew.models.validators.RegexValidator
   * --------------------------------------------------------------------------
   */
  piewpiew.models.validators.RegexValidator = piewpiew.models.validators.Validator.extend({
    regex: /./,

    defaultMessages: function() {
      return {
        invalid: c(msg.regexNoMatch)
      }
    },

    validate: function(value) {
      var errors = [];

      if (!this.regex.test(value)) {
        errors.push(piewpiew.printf(this.messages.invalid, {value: value}))
      }

      return errors;
    }
  });

  /**
   * piewpiew.models.validators.EmailValidator
   * --------------------------------------------------------------------------
   */
  piewpiew.models.validators.EmailValidator = piewpiew.models.validators.RegexValidator.extend({
    regex: /^(([^<>()[\]\\.,;:\s@\"]+(\.[^<>()[\]\\.,;:\s@\"]+)*)|(\".+\"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/,

    defaultMessages: function() {
      return {
        invalid: c(msg.emailInvalid)
      }
    }
  });  
  
  return piewpiew;
});














































(function(root, factory) {
  // If AMD is available, use the define() method to load our dependencies 
  //and declare our module
  if (typeof define === 'function' && define.amd) {
    define(['underscore', 'backbone', 'piewpiew', 'piewpiew.backbone.models.validators'], function(_, Backbone, piewpiew, validators) {
      return factory(root, _, Backbone, piewpiew, validators);
    });
  }
  // Otherwise we will attach our module to root, and pass references to our 
  // dependencies into the factory. We're assuming that our dependencies are 
  // also attached to root here, but they could come from anywhere 
  else 
  {    
    root.piewpiew = factory(root, _, Backbone, piewpiew, piewpiew.models.validators);
  }
})(this, function(root, _, Backbone, piewpiew, validators) {  

  /**
   *  piewpiew.models.fields namespace
   *  ==========================================================================
   *  
   */
  piewpiew.models || (piewpiew.models = {});
  piewpiew.models.fields || (piewpiew.models.fields = {});
  
  /**
   *  piewpiew.models.Config
   *  ==========================================================================
   *  
   *  Any and all strings for messages, templates and so forth should live here,
   *  and be retrieved by objects in the models module, rather than declared on
   *  objects themselves. Just makes it easier to change stuff as you don't need
   *  to go looking for strings hidden away in source.
   */
  piewpiew.models.fields.Config = {

    messages: {
      
      /* Field */
       required: "${label} is a required field"
      ,invalidType: "The value of ${label} is invalid"

      /* StringField */
      ,stringFieldInvalidType: "${label} must be a string"
      ,stringFieldTooLongNoMinLength: "${label} must have no more than ${maxLength} characters"
      ,stringFieldTooShortNoMaxLength: "${label} must have at least ${minLength} characters"
      ,stringFieldOutOfRange: "${label} must have between ${minLength} and ${maxLength} characters"

      /* EmailField */
      ,emailFieldInvalidEmailMessage: "${value} is not a valid email address."
    },

    templates: {
       fieldLabel: '<%= Html.label(name, value, attributes) %>' 
      ,fieldEditor: '<div <%= Html.attributeString(attributes) %>><%= Html.labelForField(model, field) %><div class="controls"><%= Html.formControlForField(model, field) %></div></div>'
      ,stringFieldFormControl: '<%= Html.textfield(name, value, attributes) %>'
    }    
  };

  // Shortcut access to config stuff  
  var c    = piewpiew.configValue;
  var conf = piewpiew.models.fields.Config;
  var msg  = piewpiew.models.fields.Config.messages;
  var tmpl = piewpiew.models.fields.Config.templates;

  /**
   *  piewpiew.models.fields.Field base class
   *  --------------------------------------------------------------------------
   *  
   */
  piewpiew.models.fields.Field = piewpiew.Class({
    /**
     * Is the field required?
     */
    required: false,

    /**
     * Error message if a value fails required validation
     */
    requiredMessage: c(msg.required),
    
    /**
     * Error message if a value is of the wrong type
     */
    invalidTypeMessage: c(msg.invalidType),
    
    /**
     * Returns a template string for rendering the field label.
     */
    labelTemplate: function() {
      return c(tmpl.fieldLabel);
    },

    /**
     * Returns a template context object for passing to our label template
     */
    labelTemplateContext: function(model) {
      return {
        name: this.name,
        value: this.label
      }; 
    },

    formControlTemplate: function() {
      return "";
    },

    formControlTemplateContext: function(model) {
      return {
        name: this.name,
        value: model.get(this.name)
      };
    },
    
    /**
     * Template for rendering an editor component for this field.
     */
    editorTemplate: function() {
      return c(tmpl.fieldEditor);
    },

    editorTemplateContext: function(model) {
      return {
        name: this.name,
        model: model,
        field: this,
        value: model.get(this.name)
      }
    },

    /**
     * Initialise the field instance.
     *
     * @param {object} options
     */
    initialize: function(options) {
      options || (options = {});

      _.extend(this, options);

      this.validators = this.defaultValidators();

      _.extend(this.validators, options.validators);
    },

    /**
     * Creates default validators for the field. Inheritting classes
     * should provide their own implementation
     */
    defaultValidators: function() {
      return {};
    },

    /**
     * Validate a value against each of our validators. If the value is valid,
     * return false, otherwise return an array of validation errors
     */
    validate: function(value) {
      var errors = [];

      // First ensure the type of value is acceptable.
      if (!this.validateType(value)) errors.push(piewpiew.printf(this.invalidTypeMessage, this));

      // Ensure required
      if (this.required && !this.validateRequired(value)) errors.push(piewpiew.printf(this.requiredMessage, this));

      _.each(this.validators, function(validator, name) {
        var v = validator.validate(value);

        if (null != v) errors = errors.concat(v);
      });

      if (errors.length > 0) return errors;

      return false;
    },

    /**
     * Ensures that the type of value is valid. Inheritting classes implement
     * their own version of this method
     *
     * @param {Object} value
     * @return {boolean}
     */
    validateType: function(value) {
      return true;
    },

    /**
     * Validates that the value is valid, if this is a required field. For 
     * example, an empty string would pass the validateType() method, but should
     * not pass the validateRequired() test.
     * @param {Object} value
     * @return {boolean}
     */
    validateRequired: function(value) {
      if (null == value) return false;

      return true;
    }    
  });

  /**
   *  piewpiew.models.fields.StringField class
   *  --------------------------------------------------------------------------
   *  
   */
  piewpiew.models.fields.StringField = piewpiew.models.fields.Field.extend({
    
    invalidTypeMessage : c(msg.stringFieldInvalidType),

    tooLongNoMinLengthMessage : c(msg.stringFieldTooLongNoMinLength),
    
    tooShortNoMaxLengthMessage : c(msg.stringFieldTooShortNoMaxLength),
    
    outOfRangeMessage : c(msg.stringFieldOutOfRange),

    minLength: -1,

    maxLength: -1,

    defaultValidators: function() {
      var self = this;

      return {
        length: new piewpiew.models.validators.StringValidator({
          minLength: self.minLength,
          maxLength: self.maxLength,
          messages: {
            tooLongNoMinLength : piewpiew.printf(self.tooLongNoMinLengthMessage, self),
            tooShortNoMaxLength : piewpiew.printf(self.tooShortNoMaxLengthMessage, self),
            outOfRange : piewpiew.printf(self.outOfRangeMessage, self)
          }
        })
      }
    },

    formControlTemplate: function() {
      return c(tmpl.stringFieldFormControl);      
    },

    validateType: function(value) {
      return (typeof value == "string");
    },

    validateRequired: function(value) {
      return value.length > 0;
    }
  });

  piewpiew.models.fields.EmailField = piewpiew.models.fields.StringField.extend({

    invalidEmailMessage: c(msg.emailFieldInvalidEmailMessage),

    defaultValidators: function() {
      var self = this;

      return {
        email: new piewpiew.models.validators.EmailValidator({
          messages: {
            invalid: self.invalidEmailMessage
          }
        })
      }
    }
  });

  return piewpiew;
});(function(root, factory) {
  // If AMD is available, use the define() method to load our dependencies 
  //and declare our module
  if (typeof define === 'function' && define.amd) {
    define(['underscore', 'backbone', 'piewpiew', 'jquery'], function(_, Backbone, piewpiew, $) {
      return factory(root, _, Backbone, piewpiew, $);
    });
  }
  // Otherwise we will attach our module to root, and pass references to our 
  // dependencies into the factory. We're assuming that our dependencies are 
  // also attached to root here, but they could come from anywhere 
  else 
  {    
    root.piewpiew = factory(root, _, Backbone, piewpiew, $);
  }
})(this, function(root, _, Backbone, piewpiew, $) {  
  
  piewpiew.views || (piewpiew.views = {});

  /**
   *  piewpiew.View base class
   *  --------------------------------------------------------------------------
   *  Adds external template support to the basic Backbone.View class, as well 
   *  as default implementations for rendering and and app registration.
   */
  piewpiew.views.View = Backbone.View.extend({

    // A default template.
    template: 'No template specified for view',

    /**
     * Template processing function. By default we use the template function 
     * provided by the underscore library. By default instances call
     * piewpiew.View.template(). You can implement per-view template functions
     * by overriding this method. If you want to override the template function
     * for all views in your app, you should override piewpiew.views.template()
     *
     * @param {String} template
     *  The unparsed template string
     * @param {Object} context
     *  The template context containing data to be rendered by the template
     * @return {String} the rendered template
     */
    templateFunction: function(template, context) {
      return piewpiew.views.template(template, context);
    },

    /**
     * Returns a template context object. A Template context is an object 
     * which encapsulates the data that will be rendered by our template
     * function. By default we simply return the result of calling our
     * model's toJSON method (assuming we have a model, and that model has a
     * toJSON method).
     *
     * In many cases you will want to override this method so that ir returns
     * data better suited to your template's requirements.
     *
     * @return {Object}
     */
    templateContext: function() {
      if (this.model) {
        if (typeof this.model.toJSON == 'function') {
          return this.model.toJSON();
        }
        return this.model;
      }
      return {};
    },

    /**
     * Renders the view. By default we pass our template string and template
     * context to templateFunction()
     */
    render: function() {
      var template = null;

      if (typeof this.template == 'function') {
        template = this.template();
      } else {
        template = this.template;
      }

      $(this.el).html(
        this.templateFunction(
          template, 
          piewpiew.views.TemplateContext(this.templateContext())
        )
      );

      return this;
    },

    /**
     * This method is called when the view is registered with the App. It
     * is often a better idea to put any view initialization code in onRegister(),
     * as opposed to initialize() as the view will have access to the App via 
     * this.app during onRegister().
     *
     * @param {piewpiew.App}
     *  the app that the view is being registered with
     */
    onRegister: function(app) {
      // noop
      return this;
    }
  });

  /**
   * Template processing function for all views. If you wish to use a templating
   * library other than the underscore template function (such as mustache etc)
   * just override this function
   *
   * @param {String} template
   *  The template string to be rendered
   * @param {Object} context
   *  The context object containing data to be rendered
   * @return {String} the rendered template
   */
  piewpiew.views.template = function(template, context) {
    return _.template(template, context);
  };

  /**
   * Builds a template context object by merging template data with our view helpers
   *
   * @param {object} data
   *  Template data
   * @return {object}
   */
  piewpiew.views.TemplateContext = function(data) {
    return _.extend(data, piewpiew.views.helpers);
  };
  
  ListView = piewpiew.views.View.extend({
    tagName: "ul",

    itemTemplate: function(item) {
      return "";
    },

    itemTemplateContext: function(item) {
      return piewpiew.view.TemplateContext(item.toJSON());
    },

    initialize: function() {
      this.collection.bind("reset", this.render, this);
      this.collection.bind("add", this.handleAdd, this);
      this.collection.bind("remove", this.handleRemove, this);
    },

    handleAdd: function(model, collection, options) {
      this.appendItem(model.toJSON());
    },

    handleRemove: function() {
      console.log("remove", arguments);
    },

    render: function() {
      var self = this;

      $(this.el).empty();

      _(this.collection.models).each(function(model) {
        self.appendItem(model);
      });

      return this;
    },

    appendItem: function(item) {
      console.log(item);
      if (this.$el) {
        this.$el.append("<li>" + item.name + "</li>");
      } else {
        this.render();
      }
    }
  });

  piewpiew.views.FormView = piewpiew.views.View.extend({

    template: function() {
      var buf = [];

      buf.push('<form class="form-horizontal">');

      if (this.model.id) {
        buf.push('<%= Html.hidden("id", model.id) %>');
      }

      buf.push('<%= Html.hidden("cid", model.cid) %>');
      buf.push('<%= Html.editorForModel(model) %>');
      buf.push('<input type="submit" value="save"/>');
      buf.push('</form>');

      return buf.join("\n");
    },

    initialize: function(options) {
      if (this.model) {
        this.model.bind("error", this.handleError, this);
      } 
    },

    templateContext: function() {
      return {
        model:this.model
      };
    },

    events: {
      'submit form': 'handleSubmit',
      'blur input': 'handleBlur',
      'focus input': 'handleFocus' 
    },

    handleSubmit: function(e) {
      var formData = this.$('form').serializeObject();

      this.clearErrors();

      if (null != this.model) {
        if (this.model.set(formData)) this.trigger("submit", this);
      }     

      e.preventDefault();
    },

    handleFocus: function(e) {

    },

    handleBlur: function(e) {
      var $field = $(e.target);
      this.clearErrorFor($field.attr('name'));
      this.model.set($field.attr('name'), $field.val());
    },

    /**
     * Handlder for our model's validation error event. Displays error messages for
     * each of the fields that failed validation.
     */
    handleError: function(model, errors) {
      var view = this;

      _.each(errors, function(messages, name) {
        var msg = view.formatErrorMessagesFor(name,messages);
        var errorEl = view.formatErrorElementFor(name, msg);
        view.clearErrorFor(name);
        view.attachErrorElementFor(name, errorEl);          
      });
    },

    /** 
     * Clears all errors from the form view. If you implement your own validation
     * error message strategy you should override this.
     */
    clearErrors: function() {
      this.$(".control-group.error .help-inline").remove();
      this.$(".control-group.error").removeClass("error");
    },

    /**
     * Clears error message for a particular field
     *
     * @param {name}
     *  Name of the field
     */
    clearErrorFor: function(name) {
      this.$(".control-group-for-"+name+".error .help-inline").remove();
      this.$(".control-group-for-"+name+".error").removeClass("error");
    },

    /**
     * Formats validation error messages for a field. Overriding classes
     * can implement their own version to provide custom formatting for
     * certain fields.
     *
     * @param {string} name
     *  The name of the field
     * @param {array} messages
     *  An an array of validation messages for the field
     */
    formatErrorMessagesFor: function(name, messages) {
      return messages.join(" ");
    },

    /**
     * Formats a label for validation error message. Used to wrap the message
     * output generated by formatMessageFor().
     *
     * @param {string} name
     *  Name of the fied the message is for
     * @param {string} message
     *  The message string
     * @return {string}
     */
    formatErrorElementFor: function(name, message) {
      return '<span class="help-inline generated">' + message + '</span>';
    },

    /**
     * Attaches a validation error element to the dom. You can override this method
     * to customise where error elements are attached in the dom, relative to their
     * associated field
     *
     * @param {string} name
     *  Name of the field that the error element is associated with
     * @param {string} errorElement
     *  HTML string for the error element
     */
    attachErrorElementFor: function(name, errorElement) {
      // Attach the element and also append the 'error' class to the containing
      // 'control-group' element. This approach is closely coupled to how our other
      // error formatting functions work. The idea is if you want to implement a
      // different error messaging strategy, then you will probably want to overwrite
      // all these functions together.
      var $input = this.$("*[name=" + name + "]");
      $input.parent().append(errorElement);
      $input.closest('.control-group').addClass('error');
    }
  });

  /**
   * Add ability to serialize jquery matches to javascript objects.
   * useful for handling form data and so forth.
   */
  $.fn.serializeObject = function()
  {
      var o = {};
      var a = this.serializeArray();
      $.each(a, function() {
          if (o[this.name] !== undefined) {
              if (!o[this.name].push) {
                  o[this.name] = [o[this.name]];
              }
              o[this.name].push(this.value || '');
          } else {
              o[this.name] = this.value || '';
          }
      });
      return o;
  };

  return piewpiew;
});














































(function(root, factory) {
  // If AMD is available, use the define() method to load our dependencies 
  //and declare our module
  if (typeof define === 'function' && define.amd) {
    define(['underscore', 'piewpiew', 'piewpiew.backbone.views'], function(_, piewpiew, views) {
      return factory(root, _, piewpiew, views);
    });
  }
  // Otherwise we will attach our module to root, and pass references to our 
  // dependencies into the factory. We're assuming that our dependencies are 
  // also attached to root here, but they could come from anywhere 
  else 
  {    
    root.piewpiew = factory(root, _, piewpiew, piewpiew.views);
  }
})(this, function(root, _, piewpiew, views) {  

  /**
   * View helpers. These methods get attached to templateContext objects when they
   * are passed to view templates for rendering.
   */
  piewpiew.views.helpers = {
    Html: {
      /**
       * Creates an HTML attributes string from an object. Name:value pairs in the
       * object will be translated into name="value" in the attribute string. The
       * one exception is for css classes. An array of css class names can be stored
       * in the "classes" property of the attributes object and it will be parsed
       * into the appropriate class attribute.
       */
      attributeString: function(htmlAttributes) {
        var buf = [];

        _.each(htmlAttributes, function(value, key) {
          if (key == "classes") {
            key = "class";
            value = value.join(" ");
          }
          buf.push(piewpiew.printf('${key}="${value}"', {key:key, value:value}));
        });

        return buf.join(" ");
      },

      editorForModel: function(model) {
        return piewpiew.views.template(
          model.editorTemplate(), 
          piewpiew.views.TemplateContext(model.editorTemplateContext())
        );
      },

      /**
       * Creates an editor control for a field, using the value of the field from
       * a particular model. The template used is determined by the value of the
       * field.editorTemplate property.
       */
      editorForField: function(model, field, htmlAttributes) {
        htmlAttributes || (htmlAttributes = {});
        htmlAttributes.classes || (htmlAttributes.classes = []);   
        htmlAttributes.classes.push("control-group");
        htmlAttributes.classes.push("control-group-for-" + field.name);

        var context = piewpiew.views.TemplateContext(field.editorTemplateContext(model));
        context.attributes = htmlAttributes;

        return piewpiew.views.template(field.editorTemplate(), context);
      },

      /**
       * Creates a form control for a field, using the value of the field from
       * a particular model. The template used is determined by the value of the
       * field.formControlTemplate property.
       */
      formControlForField: function(model, field, htmlAttributes) {
        htmlAttributes || (htmlAttributes = {});
        htmlAttributes.classes || (htmlAttributes.classes = []);   
        htmlAttributes.classes.push("control");
        htmlAttributes.classes.push("control-for-" + field.name);

        var context = piewpiew.views.TemplateContext(field.formControlTemplateContext(model));
        context.attributes = htmlAttributes;

        return piewpiew.views.template(field.formControlTemplate(), context);
      },

      /**
       * Creates a label for a field, using the value of the field from
       * a particular model. The template used is determined by the value of the
       * field.editorTemplate property.
       */
      labelForField: function(model, field, htmlAttributes) {
        htmlAttributes || (htmlAttributes = {});
        htmlAttributes.classes || (htmlAttributes.classes = []);   
        htmlAttributes.classes.push("control-label");

        var context = piewpiew.views.TemplateContext(field.labelTemplateContext(model));
        context.attributes = htmlAttributes;

        return piewpiew.views.template(field.labelTemplate(), context); 
      },

      hidden: function(name, value) {
        return piewpiew.printf('<hidden name="${name}" value="${value}"/>', {
          name:name,
          value:value
        });
      },

      label: function(name, value, htmlAttributes) {        
        return piewpiew.printf('<label for="${name}" ${attributes}>${value}</label>', {
          name: name,
          value: value,
          attributes: this.attributeString(htmlAttributes)
        });
      },

      textfield: function(name, value, htmlAttributes) {
        return piewpiew.printf('<input name="${name}" type="text" value="${value}" ${attributes}/>', {
          name: name,
          value:  (value != null) ? value : "",
          attributes: this.attributeString(htmlAttributes)
        });
      }
    }
  };

  return piewpiew;
});














































